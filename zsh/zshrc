if [[ ! -d $ZSHDATADIR ]]; then
	mkdir -p $ZSHDATADIR
fi

if [[ ! -f $ANTIGENDIR/antigen.zsh ]]; then
	mkdir -p $ANTIGENDIR
	git clone https://github.com/zsh-users/antigen.git $ANTIGENDIR
fi

source $ANTIGENDIR/antigen.zsh

antigen use oh-my-zsh

# Bundles from the default repo (robbyrussell's oh-my-zsh).
antigen bundle git
antigen bundle heroku
antigen bundle pip
antigen bundle lein
antigen bundle command-not-found
# to prevent messed up window title in tmux.
# TODO: I don't like it, find better way.
antigen bundle screen

# Syntax highlighting bundle.
antigen bundle zsh-users/zsh-syntax-highlighting

# Load the theme.
antigen theme gnzh

# Tell antigen that you're done.
antigen-apply

# keyboard configurations {{{
# to use Ctrl-s
setopt noflowcontrol

autoload zkbd

# read zkbd key codes
if [[ -f $ZDOTDIR/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE} ]]; then
	source $ZDOTDIR/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE}
fi

# setup key accordingly
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       up-line-or-history
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     down-line-or-history
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   beginning-of-buffer-or-history
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" end-of-buffer-or-history

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
	function zle-line-init ()
	{
		printf '%s' "${terminfo[smkx]}"
	}
	function zle-line-finish ()
	{
		printf '%s' "${terminfo[rmkx]}"
	}
	zle -N zle-line-init
	zle -N zle-line-finish
fi
#}}}

# Ensure some directories exist.
if [[ ! -d $HOME/.local/bin ]]; then
	mkdir -p $HOME/.local/bin
fi

if [[ ! -d $HOME/.local/share/man ]]; then
	mkdir -p $HOME/.local/share/man
fi

if [[ ! -d $HOME/.local/share/info ]]; then
	mkdir -p $HOME/.local/share/info
fi

if [[ ! -d $HOME/.local/lib ]]; then
	mkdir -p $HOME/.local/lib
fi

if [[ $(uname -m | grep 'x86_64' | wc -l) != 0 ]]; then
	if [[ ! -d $HOME/.local/lib64 ]]; then
		mkdir -p $HOME/.local/lib64
	fi

	if [[ ! -d $HOME/.local/lib32 ]]; then
		mkdir -p $HOME/.local/lib32
	fi
fi

# Set some paths
if [[ ! ":$PATH:" == *":$HOME/.local/bin:"* ]]; then
	PATH=$HOME/.local/bin:$PATH
	PATH=$(echo $PATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export PATH
fi

if [[ ! ":$(manpath):" == *":$HOME/.local/share/man:"* ]]; then
	unset MANPATH
	MANPATH=$HOME/.local/share/man:$(manpath)
	MANPATH=$(echo $MANPATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export MANPATH
fi

if [[ ! ":$INFOPATH:" == *":$HOME/.local/share/info:"* ]]; then
	INFOPATH=$HOME/.local/share/info:$INFOPATH
	INFOPATH=$(echo $INFOPATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export INFOPATH
fi

unset LD_PATH_SCRATCH
if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib:"* ]]; then
	LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib
fi

if [[ $(uname -m | grep 'x86_64' | wc -l) != 0 ]]; then
	if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib64:"* ]]; then
		LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib64
	fi

	if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib32:"* ]]; then
		LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib32
	fi
fi

LD_PATH_SCRATCH=$(echo $LD_PATH_SCRATCH | sed -e 's/^:*//g' -e 's/:*$//g')
LD_LIBRARY_PATH=$LD_PATH_SCRATCH:$LD_LIBRARY_PATH
LD_LIBRARY_PATH=$(echo $LD_LIBRARY_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
LD_RUN_PATH=$LD_PATH_SCRATCH:$LD_RUN_PATH
LD_RUN_PATH=$(echo $LD_RUN_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
unset LD_PATH_SCRATCH
export LD_LIBRARY_PATH
export LD_RUN_PATH

# vim settings
export EDITOR=vim
# Use vim to browse man pages. One can use Ctrl-] and Ctrl-t
# to browse and return from referenced man pages. ZZ or q to quit.
# Note initially within vim, one can goto the man page for the
# word under the cursor by using [section_number]K.
# Note we use bash explicitly here to support process substitution
# which in turn suppresses the "Vim: Reading from stdin..." warning.
export MANPAGER='/bin/bash -c "vim -MRn -c \"set ft=man\" </dev/tty <(col -b)"'

# force TERM environment to xterm-256color when we are in gnome-terminal
if [[ $(ps -p $PPID o comm | grep gnome-terminal | wc -l) == 1 ]]; then
	# we are in gnome-terminal.
	# gnome-terminal does not set TERM to xterm-256color
	export TERM=xterm-256color
else
	# we are not in gnome-terminal.
	:
fi

# Functions
# #########
function rmoldkernel () {
	local cur_kernel=$(uname -r|sed 's/-*[a-z]//g'|sed 's/-386//g')
	local kernel_pkg="linux-(image|image-extra|headers|ubuntu-modules|restricted-modules)"
	local meta_pkg="${kernel_pkg}-(generic|i386|virtual|server|common|rt|xen|ec2|amd64)"
	local latest_kernel=$(dpkg -l linux-image-\* | grep -E linux-image-\[0-9\] | awk '/^ii/{ print $2}' | grep -E \[0-9\] | tail -1 | cut -f3,4 -d"-")
	sudo aptitude purge -y $(dpkg -l | grep -E $kernel_pkg | grep -v -E "${cur_kernel}|${meta_pkg}|${latest_kernel}" | awk '{print $2}')
	sudo rm -rfv $(find /lib/modules/* -maxdepth 0 | grep -v -E "${cur_kernel}|${latest_kernel}" | awk '{print $1}')
	sudo update-grub2
}

function purgeremovedpkgs () {
	sudo aptitude -y purge `dpkg --get-selections | grep deinstall | cut -f1`
}

function updatepackages () {
	retry sudo aptitude update && retry sudo aptitude -d -y upgrade && sudo aptitude -y upgrade
}

if [[ -f /usr/bin/vmware-config-tools.pl ]]; then
	function reconfigurevmwaretools () {
		sudo vmware-config-tools.pl --clobber-kernel-modules=vmblock,vmhgfs,vmmemctl,vmxnet,vmci,vsock,vmsync,pvscsi,vmxnet3,vmwsvga --default
	}
fi

function retry () {
	local nTrys=0
	local maxTrys=20
	local delayBtwnTrys=333
	local laststatus=256
	until [[ $laststatus == 0 ]]; do
		$*
		laststatus=$?
		nTrys=$(($nTrys + 1))
		if [[ $nTrys -gt $maxTrys ]]; then
			echo "Number of re-trys exceeded. Exit code: $laststatus"
			exit $laststatus
		fi
		if [[ $laststatus != 0 ]]; then
			echo "Failed (exit code $status)... retry count $nTrys/$maxTrys"
			sleep $delayBtwnTrys
		fi
	done
}

# Aliases
# #######
# Some example alias instructions
# If these are enabled they will be used instead of any instructions
# they may mask. For example, alias rm='rm -i' will mask the rm
# application. To override the alias instruction use a \ before, ie
# \rm will call the real rm not the alias.
# Interactive operation...
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Default to human readable figures
alias df='df -h'
alias du='du -h'
alias ls='ls -hF --color=auto'

# astyle options
alias astyle='astyle --style=break --indent=force-tab=4 --unpad-paren --pad-header --pad-oper --unpad-paren --align-pointer=name --align-reference=name'

# axel options
alias axel='axel -a'

# wget options
alias wget='wget --retry-connrefused'

# mc options
#type -p -a mc > /dev/null && alias mc='. /usr/share/mc/bin/mc-wrapper.sh -a'
if type -p -a mc > /dev/null; then
	case "$TERM" in
		screen-256color)
			alias mc='TERM=screen . /usr/share/mc/bin/mc-wrapper.sh -a -x'
			;;
		*)
			alias mc='. /usr/share/mc/bin/mc-wrapper.sh -a'
			;;
	esac
fi

#  vim: set ft=zsh ts=4 sw=4 tw=0 noet :
