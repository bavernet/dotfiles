# Ensure $ZSHDATADIR exists {{{
if [[ ! -d $ZSHDATADIR ]]; then
	mkdir -p $ZSHDATADIR
fi
#}}}

# LS_COLORS configuration {{{
if [[ ! -f $ZSHDATADIR/LS_COLORS/LS_COLORS ]]; then
	mkdir -p $ZSHDATADIR/LS_COLORS
	git clone https://github.com/trapd00r/LS_COLORS.git $ZSHDATADIR/LS_COLORS
fi

zmodload zsh/terminfo || return 1

# only available for 256 color terminals
if (( $+terminfo[colors] )) && (( $terminfo[colors] == 256 )); then
	# load trapd00r's LS_COLORS things
	eval $( dircolors -b $ZSHDATADIR/LS_COLORS/LS_COLORS )
fi
#}}}

# Highlight style {{{
# variables for zsh-syntax-highlighting
# ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR=$ADOTDIR/repos/https-COLON--SLASH--SLASH-github.com-SLASH-zsh-users-SLASH-zsh-syntax-highlighting.git/highlighters
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
ZSH_HIGHLIGHT_MAXLENGTH=300

if (( $+terminfo[colors] )) && (( $terminfo[colors] == 256 )); then
	typeset -A ZSH_HIGHLIGHT_STYLES
	: ${ZSH_HIGHLIGHT_STYLES[default]:=none}
	: ${ZSH_HIGHLIGHT_STYLES[unknown-token]:=fg=red,bold}
	: ${ZSH_HIGHLIGHT_STYLES[reserved-word]:=fg=yellow}
	: ${ZSH_HIGHLIGHT_STYLES[alias]:=fg=226}
	: ${ZSH_HIGHLIGHT_STYLES[builtin]:=fg=141}
	: ${ZSH_HIGHLIGHT_STYLES[function]:=fg=214}
	: ${ZSH_HIGHLIGHT_STYLES[command]:=fg=118}
	: ${ZSH_HIGHLIGHT_STYLES[hashed-command]:=fg=119}
	: ${ZSH_HIGHLIGHT_STYLES[path]:=underline}
	: ${ZSH_HIGHLIGHT_STYLES[globbing]:=fg=105}
	: ${ZSH_HIGHLIGHT_STYLES[history-expansion]:=fg=63}
	: ${ZSH_HIGHLIGHT_STYLES[single-hyphen-option]:=239}
	: ${ZSH_HIGHLIGHT_STYLES[double-hyphen-option]:=241}
	: ${ZSH_HIGHLIGHT_STYLES[back-quoted-argument]:=none}
	: ${ZSH_HIGHLIGHT_STYLES[single-quoted-argument]:=fg=yellow}
	: ${ZSH_HIGHLIGHT_STYLES[double-quoted-argument]:=fg=yellow}
	: ${ZSH_HIGHLIGHT_STYLES[dollar-double-quoted-argument]:=fg=cyan}
	: ${ZSH_HIGHLIGHT_STYLES[back-double-quoted-argument]:=fg=cyan}
	: ${ZSH_HIGHLIGHT_STYLES[assign]:=none}

	: ${ZSH_HIGHLIGHT_STYLES[precommand]:=fg=227}
	: ${ZSH_HIGHLIGHT_STYLES[commandseparator]:=none}

	# and zle's very own zle_highlight
	zle_highlight=(
	region:underline
	isearch:underline
	special:bold
	suffix:fg=76
	)
fi
#}}}

# Antigen bundle configurations {{{
if [[ ! -f $ANTIGENDIR/antigen.zsh ]]; then
	mkdir -p $ANTIGENDIR
	git clone https://github.com/zsh-users/antigen.git $ANTIGENDIR
fi

source $ANTIGENDIR/antigen.zsh

antigen use oh-my-zsh

# Bundles from the default repo (robbyrussell's oh-my-zsh).
antigen bundle git
antigen bundle heroku
antigen bundle pip
antigen bundle lein
antigen bundle command-not-found
antigen bundle screen

# Syntax highlighting bundle.
antigen bundle zsh-users/zsh-syntax-highlighting

# Load the theme.
antigen theme bira

# Tell antigen that you're done.
antigen-apply
#}}}

# Keyboard configurations {{{
# to use Ctrl-s
setopt noflowcontrol

autoload zkbd

# read zkbd key codes
if [[ -f $ZDOTDIR/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE} ]]; then
	source $ZDOTDIR/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE}
fi

# setup key accordingly
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       up-line-or-history
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     down-line-or-history
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   beginning-of-buffer-or-history
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" end-of-buffer-or-history

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
	function zle-line-init ()
	{
		printf '%s' "${terminfo[smkx]}"
	}
	function zle-line-finish ()
	{
		printf '%s' "${terminfo[rmkx]}"
	}
	zle -N zle-line-init
	zle -N zle-line-finish
fi
#}}}

# Options {{{
## directory changing
# implicit cd if directory is used as command
setopt autocd
# make cd behave like pushd, and enable some convenience functions for pushd
setopt autopushd pushdignoredups
setopt pushdtohome pushdminus pushdsilent

## completion options
# list choices if completion is ambiguous
setopt autolist
# if a word matches exactly, accept it even if ambiguous
setopt recexact
# completions don't have to be equally spaced
setopt listpacked
# show file types in completion ( / for dirs, = for pipes, @ for symlinks, etc..)
setopt listtypes

## interactive type features, mostly zle stuff
# use '' inside ' quotes to write a single ' character (only interactively!)
setopt rcquotes
# allow # for comments interactively (helpful for history annotation)
setopt interactivecomments
# require >! to overwrite a file
setopt noclobber

## globbing
# enable ^, ~, # and glob flags in glob expressions (oh yes)
setopt extendedglob
# sort globs numerically (8 9 10 11, not 10 11 8 9)
setopt numericglobsort
# ~ substitution and tab completion after a = (for --x=filename args)
setopt magicequalsubst

## job control
# for single commands, resume matching jobs instead
setopt autoresume
# list jobs in long format
setopt longlistjobs
# notify us about job status changes immediately
setopt notify

## negatives
# don't run background jobs in lower prio by default
#unsetopt bgnice
# directories don't need to end in a slash
unsetopt autoparamslash
# never beep on error!
unsetopt beep
#}}}

# Path configurationsa {{{
# Ensure some directories exist.
if [[ ! -d $HOME/.local/bin ]]; then
	mkdir -p $HOME/.local/bin
fi

if [[ ! -d $HOME/.local/share/man ]]; then
	mkdir -p $HOME/.local/share/man
fi

if [[ ! -d $HOME/.local/share/info ]]; then
	mkdir -p $HOME/.local/share/info
fi

if [[ ! -d $HOME/.local/lib ]]; then
	mkdir -p $HOME/.local/lib
fi

if [[ $(uname -m | grep 'x86_64' | wc -l) != 0 ]]; then
	if [[ ! -d $HOME/.local/lib64 ]]; then
		mkdir -p $HOME/.local/lib64
	fi

	if [[ ! -d $HOME/.local/lib32 ]]; then
		mkdir -p $HOME/.local/lib32
	fi
fi

if [[ ! -d $HOME/.local/lib/pkgconfig ]]; then
	mkdir -p $HOME/.local/lib/pkgconfig
fi

# Set some paths
if [[ ! ":$PATH:" == *":$HOME/.local/bin:"* ]]; then
	PATH=$HOME/.local/bin:$PATH
	PATH=$(echo $PATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export PATH
fi

if [[ ! ":$(manpath):" == *":$HOME/.local/share/man:"* ]]; then
	unset MANPATH
	MANPATH=$HOME/.local/share/man:$(manpath)
	MANPATH=$(echo $MANPATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export MANPATH
fi

if [[ ! ":$INFOPATH:" == *":$HOME/.local/share/info:"* ]]; then
	INFOPATH=$HOME/.local/share/info:$INFOPATH
	INFOPATH=$(echo $INFOPATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export INFOPATH
fi

unset LD_PATH_SCRATCH
if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib:"* ]]; then
	LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib
fi

if [[ $(uname -m | grep 'x86_64' | wc -l) != 0 ]]; then
	if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib64:"* ]]; then
		LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib64
	fi

	if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib32:"* ]]; then
		LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib32
	fi
fi

LD_PATH_SCRATCH=$(echo $LD_PATH_SCRATCH | sed -e 's/^:*//g' -e 's/:*$//g')
LD_LIBRARY_PATH=$LD_PATH_SCRATCH:$LD_LIBRARY_PATH
LD_LIBRARY_PATH=$(echo $LD_LIBRARY_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
LD_RUN_PATH=$LD_PATH_SCRATCH:$LD_RUN_PATH
LD_RUN_PATH=$(echo $LD_RUN_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
unset LD_PATH_SCRATCH
export LD_LIBRARY_PATH
export LD_RUN_PATH

if [[ ! ":$PKG_CONFIG_PATH:" == *":$HOME/.local/lib/pkgconfig:"* ]]; then
	PKG_CONFIG_PATH=$HOME/.local/lib/pkgconfig:$PKG_CONFIG_PATH
	PKG_CONFIG_PATH=$(echo $PKG_CONFIG_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export PKG_CONFIG_PATH
fi

# grep color setting
export GREP_COLOR='1;31'

# vim settings
export EDITOR=vim
# Use vim to browse man pages. One can use Ctrl-] and Ctrl-t
# to browse and return from referenced man pages. ZZ or q to quit.
# Note initially within vim, one can goto the man page for the
# word under the cursor by using [section_number]K.
# Note we use bash explicitly here to support process substitution
# which in turn suppresses the "Vim: Reading from stdin..." warning.
export MANPAGER='/bin/bash -c "vim -MRn -c \"set ft=man\" </dev/tty <(col -b)"'

# force TERM environment to xterm-256color when we are in gnome-terminal
if [[ $(ps -p $PPID o comm | grep gnome-terminal | wc -l) == 1 ]]; then
	# we are in gnome-terminal.
	# gnome-terminal does not set TERM to xterm-256color
	export TERM=xterm-256color
else
	# we are not in gnome-terminal.
	:
fi
#}}}

# Functions {{{
function rmoldkernel () {
	local cur_kernel=$(uname -r|sed 's/-*[a-z]//g'|sed 's/-386//g')
	local kernel_pkg="linux-(image|image-extra|headers|ubuntu-modules|restricted-modules)"
	local meta_pkg="${kernel_pkg}-(generic|i386|virtual|server|common|rt|xen|ec2|amd64)"
	local latest_kernel=$(dpkg -l linux-image-\* | grep -E linux-image-\[0-9\] | awk '/^ii/{ print $2}' | grep -E \[0-9\] | tail -1 | cut -f3,4 -d"-")
	sudo aptitude purge -y $(dpkg -l | grep -E $kernel_pkg | grep -v -E "${cur_kernel}|${meta_pkg}|${latest_kernel}" | awk '{print $2}')
	sudo rm -rfv $(find /lib/modules/* -maxdepth 0 | grep -v -E "${cur_kernel}|${latest_kernel}" | awk '{print $1}')
	sudo update-grub2
}

function purgeremovedpkgs () {
	sudo aptitude -y purge `dpkg --get-selections | grep deinstall | cut -f1`
}

function updatepackages () {
	retry sudo aptitude update && retry sudo aptitude -d -y upgrade && sudo aptitude -y upgrade
}

if [[ -f /usr/bin/vmware-config-tools.pl ]]; then
	function reconfigurevmwaretools () {
		sudo vmware-config-tools.pl --clobber-kernel-modules=vmblock,vmhgfs,vmmemctl,vmxnet,vmci,vsock,vmsync,pvscsi,vmxnet3,vmwsvga --default
	}
fi

function retry () {
	local nTrys=0
	local maxTrys=20
	local delayBtwnTrys=3
	local laststatus=256
	until [[ $laststatus == 0 ]]; do
		$*
		laststatus=$?
		nTrys=$(($nTrys + 1))
		if [[ $nTrys -gt $maxTrys ]]; then
			echo "Number of re-trys exceeded. Exit code: $laststatus"
			exit $laststatus
		fi
		if [[ $laststatus != 0 ]]; then
			echo "Failed (exit code $status)... retry count $nTrys/$maxTrys"
			sleep $delayBtwnTrys
		fi
	done
}
#}}}

# Aliases {{{
# Some example alias instructions
# If these are enabled they will be used instead of any instructions
# they may mask. For example, alias rm='rm -i' will mask the rm
# application. To override the alias instruction use a \ before, ie
# \rm will call the real rm not the alias.
# Interactive operation...
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Default to human readable figures
alias df='df -h'
alias du='du -h'
alias ls='ls -hF --color=auto'

# astyle options
alias astyle='astyle --style=break --indent=force-tab=4 --unpad-paren --pad-header --pad-oper --unpad-paren --align-pointer=name --align-reference=name'

# axel options
alias axel='axel -a'

# wget options
alias wget='wget --retry-connrefused'

# mc options
#type -p -a mc > /dev/null && alias mc='. /usr/share/mc/bin/mc-wrapper.sh -a'
if type -p -a mc > /dev/null; then
	unset MCWRAPPERSH
	if [[ -x $HOME/.local/libexec/mc/mc-wrapper.sh ]]; then
		local MCWRAPPERSH="$HOME/.local/libexec/mc/mc-wrapper.sh"
	else
		if [[ -x /usr/share/mc/bin/mc-wrapper.sh ]]; then
			local MCWRAPPERSH="/usr/share/mc/bin/mc-wrapper.sh"
		fi
	fi
	case "$TERM" in
		screen-256color)
			alias mc="TERM=screen . $MCWRAPPERSH -a -x"
			;;
		*)
			alias mc=". $MCWRAPPERSH -a"
			;;
	esac
fi
#}}}

# Window title setting {{{
# try to give the window a meaningful title, at least some of the time

# use terminfo data to set title. this works with urxvt and probably others
title-set-terminfo () {
	print -nR "$terminfo[tsl]$1 ${*[2,$]}$terminfo[fsl]"
}
# xterm doesn't work with terminfo -> special treatment
title-set-xterm () {
	print -nR $'\033]0;'$1 ${*[2,$]}$'\007'
}

# set tab title in screen
title-set-screen () {
	# tab title only uses $1
	print -nR $'\033k'$1$'\033\\'
}

# run some application, maybe? set title to "command (pwd)"
title-preexec () {

	# don't bother if nopony's listening anyways
	(( $#title_functions > 0 )) || return

	local -a buf
	buf=( ${(z)1} )

	# straight from zsh-syntax-highlighting :)
	precommands=( 'builtin' 'command' 'exec' 'nocorrect' 'noglob' 'sudo' 'time' )

	# first is a precommand? shift dis shit.
	local prefix
	while (( $+precommands[(r)$buf[1]] )); do
		if [[ $buf[1] == sudo ]]; then

			# show sudo as a prefix
			prefix="sudo "

			# shift away all sudo-args, so the next one should be the command
			shift buf
			while [[ $buf[1] == -* ]]; do
				shift buf
			done

		else
			shift buf
		fi
	done

	# only care for a couple of command-type types. "for" is hardly a useful title
	local typ=${"$(LC_ALL=C builtin whence -w $buf[1] 2>/dev/null)"#*: }
	[[ $typ == "function" || $typ == "command" || $typ == "alias" ]] || return

	local f
	for f in $title_functions; do
		$f "$prefix${buf[1]:t}" "(${(D)PWD})"
	done

}

# back to the prompt, title is "zsh (pwd)"
title-precmd () {

	local f
	for f in $title_functions; do
		$f zsh "(${(D)PWD})"
	done

}

# array of functions to call for title setting
typeset -aH title_functions

# if we can get tsl from terminfo, that'd be perfect. works with urxvt.
zmodload zsh/terminfo
if (( $+terminfo[tsl] && $+terminfo[fsl] )); then
	title_functions+=( title-set-terminfo )
	# otherwise, fallback for specific terminals (maybe expand this list?)
elif [[ $TERM == xterm* ]]; then
	title_functions+=( title-set-xterm )
fi

# set screen title independently
if [[ $TERM == screen* ]]; then
	title_functions+=( title-set-screen )
fi

# we do this regardless, to always provide title_functions functionality
autoload -U add-zsh-hook
add-zsh-hook preexec title-preexec
add-zsh-hook precmd title-precmd
#}}}

#  vim: set ft=zsh ts=4 sts=4 sw=4 tw=0 noet fdm=marker :
