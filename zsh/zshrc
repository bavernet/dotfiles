# Determine system environment {{{
function determine-sysenv()
{
	_SYSENV_OS=${$(uname):l}
	_SYSENV_KERNEL=$(uname -r)
	_SYSENV_MACH=$(uname -m)

	if [[ "${_SYSENV_OS}" == "windowsnt" ]]; then
		_SYSENV_OS=windows
	elif [[ "${_SYSENV_OS}" == "darwin" ]]; then
		_SYSENV_OS=macos
	elif [[ "${_SYSENV_OS}" =~ "^cygwin" ]]; then
		_SYSENV_OS=cygwin
	else
		_SYSENV_OS=$(uname)
		if [[ "${_SYSENV_OS}" == "SunOS" ]]; then
			_SYSENV_OS=Solaris
			_SYSENV_ARCH=$(uname -p)
			_SYSENV_OSSTR="${_SYSENV_OS} ${_SYSENV_REV}(${_SYSENV_ARCH} $(uname -v))"
		elif [[ "${_SYSENV_OS}" == "AIX" ]]; then
			_SYSENV_OSSTR="${_SYSENV_OS} $(oslevel) ($(oslevel -r))"
		elif [[ "${_SYSENV_OS}" == "Linux" ]]; then
			if [[ -f /etc/redhat-release ]]; then
				_SYSENV_DISTROBASEDON='RedHat'
				_SYSENV_DIST=$(cat /etc/redhat-release | sed s/\ release.*//)
				_SYSENV_PSEUDONAME=$(cat /etc/redhat-release | sed s/.*\(// | sed s/\)//)
				_SYSENV_REV=$(cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//)
			elif [[ -f /etc/SuSE-release ]]; then
				_SYSENV_DISTROBASEDON='SuSe'
				_SYSENV_PSEUDONAME=$(cat /etc/SuSE-release | tr "\n" ' '| sed s/VERSION.*//)
				_SYSENV_REV=$(cat /etc/SuSE-release | tr "\n" ' ' | sed s/.*=\ //)
			elif [[ -f /etc/mandrake-release ]]; then
				_SYSENV_DISTROBASEDON='Mandrake'
				_SYSENV_PSEUDONAME=$(cat /etc/mandrake-release | sed s/.*\(// | sed s/\)//)
				_SYSENV_REV=$(cat /etc/mandrake-release | sed s/.*release\ // | sed s/\ .*//)
			elif [[ -f /etc/debian_version ]]; then
				_SYSENV_DISTROBASEDON='Debian'
				if [[ -f /etc/lsb-release ]]; then
					_SYSENV_DIST=$(cat /etc/lsb-release | grep '^DISTRIB_ID' | awk -F= '{ print $2 }')
					_SYSENV_PSEUDONAME=$(cat /etc/lsb-release | grep '^DISTRIB_CODENAME' | awk -F= '{ print $2 }')
					_SYSENV_REV=$(cat /etc/lsb-release | grep '^DISTRIB_RELEASE' | awk -F= '{ print $2 }')
				fi
			fi
			if [[ -f /etc/UnitedLinux-release ]]; then
				_SYSENV_DIST="${_SYSENV_DIST}[$(cat /etc/UnitedLinux-release | tr "\n" ' ' | sed s/VERSION.*//)]"
			fi
			_SYSENV_OS=${_SYSENV_OS:l}
			_SYSENV_DIST=${_SYSENV_DIST:l}
			_SYSENV_DISTROBASEDON=${_SYSENV_DISTROBASEDON:l}
		fi
	fi
}

determine-sysenv
readonly _SYSENV_OS _SYSENV_OSSTR _SYSENV_DIST _SYSENV_DISTROBASEDON \
	SYSENV_PSEUDONAME _SYSENV_REV _SYSENV_KERNEL _SYSENV_MACH
#}}}

# Path configurations {{{
# Ensure some directories exist.
if [[ ! -d $HOME/.local/bin ]]; then
	mkdir -p $HOME/.local/bin
fi

if [[ ! -d $HOME/.local/share/man ]]; then
	mkdir -p $HOME/.local/share/man
fi

if [[ ! -d $HOME/.local/share/info ]]; then
	mkdir -p $HOME/.local/share/info
fi

if [[ ! -d $HOME/.local/lib ]]; then
	mkdir -p $HOME/.local/lib
fi

if [[ $(uname -m | grep 'x86_64' | wc -l) != 0 ]]; then
	if [[ ! -d $HOME/.local/lib64 ]]; then
		mkdir -p $HOME/.local/lib64
	fi

	if [[ ! -d $HOME/.local/lib32 ]]; then
		mkdir -p $HOME/.local/lib32
	fi
fi

if [[ ! -d $HOME/.local/lib/pkgconfig ]]; then
	mkdir -p $HOME/.local/lib/pkgconfig
fi

# Set some paths
if [[ ! ":$PATH:" == *":$HOME/.local/bin:"* ]]; then
	PATH=$HOME/.local/bin:$PATH
	PATH=$(echo $PATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export PATH
fi

if [[ ! ":$(manpath):" == *":$HOME/.local/share/man:"* ]]; then
	unset MANPATH
	MANPATH=$HOME/.local/share/man:$(manpath)
	MANPATH=$(echo $MANPATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export MANPATH
fi

if [[ ! ":$INFOPATH:" == *":$HOME/.local/share/info:"* ]]; then
	INFOPATH=$HOME/.local/share/info:$INFOPATH
	INFOPATH=$(echo $INFOPATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export INFOPATH
fi

unset LD_PATH_SCRATCH
if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib:"* ]]; then
	LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib
fi

if [[ $(uname -m | grep 'x86_64' | wc -l) != 0 ]]; then
	if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib64:"* ]]; then
		LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib64
	fi

	if [[ ! ":$LD_LIBRARY_PATH:" == *":$HOME/.local/lib32:"* ]]; then
		LD_PATH_SCRATCH=$LD_PATH_SCRATCH:$HOME/.local/lib32
	fi
fi

LD_PATH_SCRATCH=$(echo $LD_PATH_SCRATCH | sed -e 's/^:*//g' -e 's/:*$//g')
LD_LIBRARY_PATH=$LD_PATH_SCRATCH:$LD_LIBRARY_PATH
LD_LIBRARY_PATH=$(echo $LD_LIBRARY_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
LD_RUN_PATH=$LD_PATH_SCRATCH:$LD_RUN_PATH
LD_RUN_PATH=$(echo $LD_RUN_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
unset LD_PATH_SCRATCH
export LD_LIBRARY_PATH
export LD_RUN_PATH

if [[ ! ":$PKG_CONFIG_PATH:" == *":$HOME/.local/lib/pkgconfig:"* ]]; then
	PKG_CONFIG_PATH=$HOME/.local/lib/pkgconfig:$PKG_CONFIG_PATH
	PKG_CONFIG_PATH=$(echo $PKG_CONFIG_PATH | sed -e 's/^:*//g' -e 's/:*$//g')
	export PKG_CONFIG_PATH
fi
#}}}

# TERM variable {{{
# force TERM environment to xterm-256color when we are in gnome-terminal
if [[ $(ps -p $PPID o comm | grep gnome-terminal | wc -l) == 1 ]]; then
	# we are in gnome-terminal.
	# gnome-terminal does not set TERM to xterm-256color
	export TERM=xterm-256color
else
	# we are not in gnome-terminal.
	:
fi

# if you want to force TERM to xterm-256color
#export TERM=xterm-256color
#}}}

# Variables for tmux bundle {{{
ZSH_TMUX_AUTOSTART=false
ZSH_TMUX_AUTOSTART_ONCE=false
ZSH_TMUX_AUTOCONNECT=false
ZSH_TMUX_AUTOQUIT=false
ZSH_TMUX_FIXTERM=true
#}}}

# Ensure $ZSHDATADIR exists {{{
if [[ ! -d $ZSHDATADIR ]]; then
	mkdir -p $ZSHDATADIR
fi
#}}}

# Antigen bundle configurations {{{
if [[ ! -f $ANTIGENDIR/antigen.zsh ]]; then
	mkdir -p $ANTIGENDIR
	git clone https://github.com/zsh-users/antigen.git $ANTIGENDIR
fi

source $ANTIGENDIR/antigen.zsh

antigen use oh-my-zsh

# Bundles from the default repo (robbyrussell's oh-my-zsh).
antigen bundle git
antigen bundle tmux
antigen bundle screen

# Syntax highlighting bundle.
antigen bundle zsh-users/zsh-syntax-highlighting

if [[ $_SYSENV_DIST == "ubuntu" ]]; then
	antigen bundle command-not-found
fi

if [[ $_SYSENV_OS == "macos" ]]; then
	antigen bundle brew
fi

# more LS_COLORS
# only available for 256 color terminals
zmodload zsh/terminfo || return 1
if (( $+terminfo[colors] )) && (( $terminfo[colors] == 256 )); then
	antigen bundle trapd00r/LS_COLORS
fi

# Load the theme.
antigen theme bira

# Tell antigen that you're done.
antigen-apply
#}}}

# LS_COLORS configuration {{{
# only available for 256 color terminals
if (( $+terminfo[colors] )) && (( $terminfo[colors] == 256 )); then
	# load trapd00r's LS_COLORS things
	eval $( dircolors -b $ADOTDIR/repos/https-COLON--SLASH--SLASH-github.com-SLASH-trapd00r-SLASH-LS_COLORS.git/LS_COLORS )
fi
#}}}

# Highlight style {{{
# variables for zsh-syntax-highlighting
ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR=$ADOTDIR/repos/https-COLON--SLASH--SLASH-github.com-SLASH-zsh-users-SLASH-zsh-syntax-highlighting.git/highlighters
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
ZSH_HIGHLIGHT_MAXLENGTH=300

if (( $+terminfo[colors] )) && (( $terminfo[colors] == 256 )); then
	typeset -A ZSH_HIGHLIGHT_STYLES
	: ${ZSH_HIGHLIGHT_STYLES[default]:=none}
	: ${ZSH_HIGHLIGHT_STYLES[unknown-token]:=fg=red,bold}
	: ${ZSH_HIGHLIGHT_STYLES[reserved-word]:=fg=yellow}
	: ${ZSH_HIGHLIGHT_STYLES[alias]:=fg=226}
	: ${ZSH_HIGHLIGHT_STYLES[builtin]:=fg=141}
	: ${ZSH_HIGHLIGHT_STYLES[function]:=fg=214}
	: ${ZSH_HIGHLIGHT_STYLES[command]:=fg=118}
	: ${ZSH_HIGHLIGHT_STYLES[hashed-command]:=fg=119}
	: ${ZSH_HIGHLIGHT_STYLES[path]:=underline}
	: ${ZSH_HIGHLIGHT_STYLES[globbing]:=fg=105}
	: ${ZSH_HIGHLIGHT_STYLES[history-expansion]:=fg=63}
	: ${ZSH_HIGHLIGHT_STYLES[single-hyphen-option]:=239}
	: ${ZSH_HIGHLIGHT_STYLES[double-hyphen-option]:=241}
	: ${ZSH_HIGHLIGHT_STYLES[back-quoted-argument]:=none}
	: ${ZSH_HIGHLIGHT_STYLES[single-quoted-argument]:=fg=yellow}
	: ${ZSH_HIGHLIGHT_STYLES[double-quoted-argument]:=fg=yellow}
	: ${ZSH_HIGHLIGHT_STYLES[dollar-double-quoted-argument]:=fg=cyan}
	: ${ZSH_HIGHLIGHT_STYLES[back-double-quoted-argument]:=fg=cyan}
	: ${ZSH_HIGHLIGHT_STYLES[assign]:=none}

	: ${ZSH_HIGHLIGHT_STYLES[precommand]:=fg=227}
	: ${ZSH_HIGHLIGHT_STYLES[commandseparator]:=none}

	# and zle's very own zle_highlight
	zle_highlight=(
	region:underline
	isearch:underline
	special:bold
	suffix:fg=76
	)
fi
#}}}

# Keyboard configurations {{{
# to use Ctrl-s
setopt noflowcontrol
stty -ixon

autoload zkbd

# read zkbd key codes
if [[ -f $ZDOTDIR/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE} ]]; then
	source $ZDOTDIR/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE}
fi

# setup key accordingly
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Up]}"       ]]  && bindkey  "${key[Up]}"       up-line-or-history
[[ -n "${key[Down]}"     ]]  && bindkey  "${key[Down]}"     down-line-or-history
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   beginning-of-buffer-or-history
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" end-of-buffer-or-history

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
	function zle-line-init ()
	{
		printf '%s' "${terminfo[smkx]}"
	}
	function zle-line-finish ()
	{
		printf '%s' "${terminfo[rmkx]}"
	}
	zle -N zle-line-init
	zle -N zle-line-finish
fi
#}}}

# Options {{{
setopt auto_cd
setopt auto_pushd pushd_ignore_dups
setopt pushd_to_home pushd_minus pushd_silent

setopt auto_list
setopt list_packed
setopt list_types

setopt rc_quotes
setopt interactive_comments
setopt no_clobber
unsetopt rm_star_silent

setopt extended_glob
setopt numeric_glob_sort
setopt magic_equal_subst

setopt auto_resume
setopt bg_nice
setopt long_list_jobs
setopt notify

unsetopt auto_param_slash
unsetopt beep
unsetopt hist_beep
unsetopt list_beep
#}}}

# History options {{{
# history file location set in .zshenv
HISTSIZE=10000
SAVEHIST=10000

setopt hist_ignore_all_dups
unsetopt hist_ignore_space

setopt append_history
setopt inc_append_history

setopt hist_reduce_blanks
setopt hist_verify
setopt share_history
setopt bang_hist
setopt extended_history
#}}}

# Variables {{{
# grep color setting
export GREP_COLOR='1;31'

# vim settings
export EDITOR=vim

# Use vim to browse man pages. One can use Ctrl-] and Ctrl-t
# to browse and return from referenced man pages. ZZ or q to quit.
# Note initially within vim, one can goto the man page for the
# word under the cursor by using [section_number]K.
# Note we use bash explicitly here to support process substitution
# which in turn suppresses the "Vim: Reading from stdin..." warning.
export MANPAGER='/bin/bash -c "vim -MRn -c \"set ft=man\" </dev/tty <(col -b)"'
#}}}

# Functions {{{
if [[ $_SYSENV_DIST == "ubuntu" ]]; then
	function clean-old-kernels()
	{
		local cur_kernel=$(uname -r|sed 's/-*[a-z]//g'|sed 's/-386//g')
		local kernel_pkg="linux-(image|image-extra|headers|ubuntu-modules|restricted-modules)"
		local meta_pkg="${kernel_pkg}-(generic|i386|virtual|server|common|rt|xen|ec2|amd64)"
		local latest_kernel=$(dpkg -l linux-image-\* | grep -E linux-image-\[0-9\] | awk '/^ii/{ print $2}' | grep -E \[0-9\] | tail -1 | cut -f3,4 -d"-")
		sudo aptitude purge -y $(dpkg -l | grep -E $kernel_pkg | grep -v -E "${cur_kernel}|${meta_pkg}|${latest_kernel}" | awk '{print $2}')
		sudo rm -rfv $(find /lib/modules/* -maxdepth 0 | grep -v -E "${cur_kernel}|${latest_kernel}" | awk '{print $1}')
		sudo update-grub2
	}

	function clean-packages()
	{
		sudo aptitude -y autoclean
		sudo aptitude -y purge `dpkg --get-selections | grep deinstall | cut -f1`
	}

	function update-packages()
	{
		retry sudo aptitude update && retry sudo aptitude -d -y upgrade && sudo aptitude -y upgrade
	}
fi

if [[ -f /usr/bin/vmware-config-tools.pl ]]; then
	function reconfigure-vmware-tools()
	{
		sudo vmware-config-tools.pl --clobber-kernel-modules=vmblock,vmhgfs,vmmemctl,vmxnet,vmci,vsock,vmsync,pvscsi,vmxnet3,vmwsvga --default
	}
fi

function retry()
{
	local nTrys=0
	local maxTrys=20
	local delayBtwnTrys=3
	local lastStatus=256
	until [[ $lastStatus == 0 ]]; do
		$*
		lastStatus=$?
		nTrys=$(($nTrys + 1))
		if [[ $nTrys -gt $maxTrys ]]; then
			echo "Number of re-trys exceeded. Exit code: $lastStatus"
			exit $lastStatus
		fi
		if [[ $lastStatus != 0 ]]; then
			echo "Failed (exit code $lastStatus)... retry count $nTrys/$maxTrys"
			sleep $delayBtwnTrys
		fi
	done
}
#}}}

# Aliases {{{
# Some example alias instructions
# If these are enabled they will be used instead of any instructions
# they may mask. For example, alias rm='rm -i' will mask the rm
# application. To override the alias instruction use a \ before, ie
# \rm will call the real rm not the alias.
# Interactive operation...
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Default to human readable figures
alias df='df -h'
alias du='du -h'
alias ls='ls -hF --color=auto'

# astyle options
alias astyle='astyle --style=break --indent=force-tab=4 --unpad-paren --pad-header --pad-oper --unpad-paren --align-pointer=name --align-reference=name'

# axel options
alias axel='axel -a'

# wget options
alias wget='wget --retry-connrefused'

# mc options
#type -p -a mc > /dev/null && alias mc='. /usr/share/mc/bin/mc-wrapper.sh -a'
if type -p -a mc > /dev/null; then
	unset MCWRAPPERSH
	if [[ -x $HOME/.local/libexec/mc/mc-wrapper.sh ]]; then
		local MCWRAPPERSH="$HOME/.local/libexec/mc/mc-wrapper.sh"
	elif [[ -x /usr/share/mc/bin/mc-wrapper.sh ]]; then
		local MCWRAPPERSH="/usr/share/mc/bin/mc-wrapper.sh"
	fi
	if [[ ! -z $MCWRAPPERSH ]]; then
		case "$TERM" in
			screen-256color)
				alias mc="TERM=screen . $MCWRAPPERSH -a -x"
				;;
			*)
				alias mc=". $MCWRAPPERSH -a"
				;;
		esac
	fi
fi
#}}}

# Window title setting {{{
# try to give the window a meaningful title, at least some of the time

# use terminfo data to set title. this works with urxvt and probably others
title-set-terminfo()
{
	print -nR "$terminfo[tsl]$1 ${*[2,$]}$terminfo[fsl]"
}

# xterm doesn't work with terminfo -> special treatment
title-set-xterm()
{
	print -nR $'\033]0;'$1 ${*[2,$]}$'\007'
}

# set tab title in screen
title-set-screen()
{
	# tab title only uses $1
	print -nR $'\033k'$1$'\033\\'
}

# run some application, maybe? set title to "command (pwd)"
title-preexec()
{
	# don't bother if nopony's listening anyways
	(( $#title_functions > 0 )) || return

	local -a buf
	buf=( ${(z)1} )

	# straight from zsh-syntax-highlighting :)
	precommands=( 'builtin' 'command' 'exec' 'nocorrect' 'noglob' 'sudo' 'time' )

	# first is a precommand? shift dis shit.
	local prefix
	while (( $+precommands[(r)$buf[1]] )); do
		if [[ $buf[1] == sudo ]]; then

			# show sudo as a prefix
			prefix="sudo "

			# shift away all sudo-args, so the next one should be the command
			shift buf
			while [[ $buf[1] == -* ]]; do
				shift buf
			done

		else
			shift buf
		fi
	done

	# only care for a couple of command-type types. "for" is hardly a useful title
	local typ=${"$(LC_ALL=C builtin whence -w $buf[1] 2>/dev/null)"#*: }
	[[ $typ == "function" || $typ == "command" || $typ == "alias" ]] || return

	local f
	for f in $title_functions; do
		$f "$prefix${buf[1]:t}" "(${(D)PWD})"
	done
}

# back to the prompt, title is "zsh (pwd)"
title-precmd()
{
	local f
	for f in $title_functions; do
		$f zsh "(${(D)PWD})"
	done
}

# array of functions to call for title setting
typeset -aH title_functions

# if we can get tsl from terminfo, that'd be perfect. works with urxvt.
zmodload zsh/terminfo
if (( $+terminfo[tsl] && $+terminfo[fsl] )); then
	title_functions+=( title-set-terminfo )
	# otherwise, fallback for specific terminals (maybe expand this list?)
elif [[ $TERM == xterm* ]]; then
	title_functions+=( title-set-xterm )
fi

# set screen title independently
if [[ $TERM == screen* ]]; then
	title_functions+=( title-set-screen )
fi

# we do this regardless, to always provide title_functions functionality
autoload -U add-zsh-hook
add-zsh-hook preexec title-preexec
add-zsh-hook precmd title-precmd
#}}}

#  vim: set ft=zsh ts=4 sts=4 sw=4 tw=0 noet fdm=marker :
